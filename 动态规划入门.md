动态规划入门
===========

## 概念

动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。

动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。

使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。

**概念总是抽象的，从实际例子理解会好很多**

## 例子1： 斐波那契

在计算机中，很经典的一个问题就是求斐波那契数列的第n项。

我们固然可以用通项公式：
$
a_{n} = \frac{\frac{2}{\sqrt 5 + 1} - \frac{1}{{(\sqrt 5 + \frac{1}{2})}^{n}}}{\sqrt 5}
$
在 $O(1)$ 时间复杂度内解决问题。但要注意的是，我们现在学的是计算机，不是数学。

### 递归

回到计算机，我们可以用很经典的递归解决这个问题，我们已知第一项 $a_{1} = 1$，第二项 $a_{2} = 1$ ,且之后的每一项都等于前两项之和。于是可以写出程序：

```Python
def fib(n: int) -> int:
    if n == 1:
        return 1
    if n == 2:
        return 1
    return fib(n - 1) + fib(n - 2)
```

这个递归程序实际上是很好理解的，但我们要考虑到一个问题，**时间复杂度**。

我们假设 `n = 8` ，于是按照我们这个程序，就会执行代码 `fib(7) + fib(6)` ，而 `fib(7)` 又会执行 `fib(6) + fib(5)` ， `fib(6)` 又会执行 `fib(5) + fib(4)` ...

于是乎，我们可以发现，我们其实计算了很多相同的结果，比如我们多次计算了 `fib(5)` ，这些计算显然很浪费时间。

### 动态规划

既然有很多重复计算，那我们为什么不把每个计算结果都存起来，需要用的时候直接拿就行了呢？说干就干

我们尝试用一个列表将所有的斐波那契项存起来，需要用到的时候直接从列表中拿就行了：

```Python
def fib(n: int) -> int:
    if n == 1:
        return 1
    if n == 2:
        return 2
    # 预设一个大小为n + 1的数组，dp[n]表示斐波那契数列的第n项
    dp = [0] * (n + 1)
    
    # 第一项a1 = 1, 第二项a2 = 2
    dp[1], dp[2] = 1, 1
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    # 返回第n项
    return dp[n]
```

这样，我们就成功的保证每一项都只计算一次，将时间复杂度降到了$O(n)$。

当然，我们可以再做优化，注意到实际上我们每次都只用到前两项，于是，优化为：

```Python
def fib(n: int) -> int:
    if n == 1:
        return 1
    if n == 2:
        return 2
    # 只需要前两项
    pre1 = 1
    pre2 = 1
    for i in range(3, n + 1):
        pre1, pre2 = pre2, pre1
        pre2 = pre1 + pre2
    # 返回第n项
    return pre2
```

## 从例子1看动态规划

在代码中，我们尝试用一个大数组dp存储斐波那契数列的每一项，这其实就是动态规划里很重要的一个点：存储既有结果。比如在斐波那契数列中，我们定义 `dp[n]` 为斐波那契的第n项，将结果储存进去。

动态规划还有一个很重要的东西：状态转移方程。

名字很高大上，其实就是如何从已经算好的部分，得到要计算部分的值，的一个方程。在这里，很明显，状态转移方程就是 `dp[n] = dp[n - 1] + dp[n - 2]` 。状态转移方程可以说是动态规划中最重要的部分，只要将状态转移方程解决了，其实整个问题就好做了。

## 例子2：打家劫舍

打家劫舍也是动态规划中很经典的一个问题。

### 问题：

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 示例：

输入：`nums = [1,2,3,1]`

输出：`4`

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

[打家劫舍](https://leetcode.cn/problems/house-robber/description/)

我们尝试用动态规划解决这个问题。

首先是存储既有结果，我们可以用一个大数组 dp ，其中，dp[i] 表示打劫前i座房子能得到的最大价值。

其次是考虑状态转移方程。已知 dp[i] 表示打劫前i座房子能得到的最大价值，那么打劫前k座房子的最大价值，我们有状态转移方程：

$dp[k] = max(dp[k - 1], dp[k - 2] + nums[k])$

你可能会有疑问，我打劫前 k 座房子，为什么不能有 $dp[k - 1] + nums[k]$ 呢？打劫前 k - 1 座房子得到最大价值的方式未必会需要打劫到第 k - 1 座房子啊！确实是这样的，但如果得到前 k - 1 座房子最大价值的打劫方式不需要打劫第 k - 1 座房子，那么不就有 $dp[k - 1] == dp[k - 2]$ 了？于是 $dp[k - 1] + nums[k]$ 不就跟 $dp[k - 2] + nums[k]$ 一样了吗？

于是，我们现在有了动态规划所需要的全部东西，可以尝试转思想为代码了：

```Python
def rob(nums: List[int]) -> int:
    n = len(nums)
    if n == 1: return nums[0]
    dp = [0] * (n + 1)
    dp[1] = nums[0]
    for i in range(2, n + 1):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
    return dp[n]
```

与前面一样，我们每次都只需要用到两个前置项，于是可以优化空间：

```Python
def rob(nums: List[int]) -> int:
    pre1, pre2 = 0, 0
    for i in nums:
        pre1, pre2 = pre2, max(pre1 + i, pre2)
    return pre2
```

## 例子3：最长递增子序列

我们已经尝试过不少动态规划的问题了，现在再来看一个问题

### 问题：

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

### 示例：

输入：nums = `[10,9,2,5,3,7,101,18]`

输出：4

解释：最长递增子序列是 `[2,3,7,101]`，因此长度为 4 。

[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

同样的，我们先建一个大数组 dp ，然后就考虑 dp[i] 表示什么。在这里，我们可以考虑，dp[i] 是以下标 i 结尾的最长递增子串的长度。

然后我们再考虑状态转移方程。显然，以下标 i 结尾的最长递增子串，可以通过寻找之前的小于 nums[i] 位置的结果 + 1 得到，于是状态转移方程可以是：

$dp[i] = max(dp[k_{1}], dp[k_{2}] ... dp[k_{n}])  + 1$

其中 $k_1 .. k_n$ 是 i 之前所有小于 nums[i] 元素的下标。

有了需要的元素，我们就能用动态规划解决问题：

```Python
def lengthOfLIS(self, nums: List[int]) -> int:
    n = len(nums)
    dp = [1] * n
    ans = 1
    for i in range(1, n):
        for j in range(i - 1, -1, -1):
            if nums[j] < nums[i]:
                dp[i] = max(dp[j] + 1, dp[i])
            ans = max(ans, dp[i])
    return ans
```

**需要注意的是，这道题的最优解法并不是动态规划，鉴于我们此处只学习动态规划，故不解释最优解法。**

### 最优解法：

```Python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        d = []
        for n in nums:
            if not d or n > d[-1]:
                d.append(n)
            else:
                l, r = 0, len(d) - 1
                loc = r
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        loc = mid
                        r = mid - 1
                    else:
                        l = mid + 1
                d[loc] = n
        return len(d)
```

## 二维动态规划

**由于只讲动态规划入门，因此此处只举一例二维动态规划的问题。**

### 最长公共子序列：

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 `0` 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

+ 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

### 示例：

输入：text1 = `"abcde"`, text2 = `"ace"`

输出：3

解释：最长公共子序列是 `"ace"` ，它的长度为 3 。

[最长公共子序列](https://leetcode.cn/problems/qJnOS7/description/)

我们还是考虑建一个大数组，由于这里涉及到两个字符串，于是我们尝试用一个二维的大数组 dp ，其中 dp[i][j] 表示 `text1` 前 i 个字符部分与 `text2` 前 j 个字符部分最长的公共子串。

然后我们再考虑状态转移方程。如果当前的两个字符：`text1[i - 1]`，`text2[j - 1]` 相等，那么显然就有：

$dp[i][j] = dp[i - 1][j - 1] + 1$

如果不相等，那么该处就取 `text1` 前 i - 1 个字符、`text2` 前 j 个字符的结果，与 `text1` 前 i 个字符、`text2` 前 j - 1 个字符的结果，其中较大的一个。就会有：

$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$

于是我们可以写出程序：

```Python
def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1 = len(text1)
        n2 = len(text2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        ans = 0
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
        return dp[n1][n2]
```